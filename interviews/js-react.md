## [Делегирование событий](https://learn.javascript.ru/event-delegation)

Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование.

Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.

Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

### Приём проектирования «поведение»

Делегирование событий можно использовать для добавления элементам «поведения» (behavior), декларативно задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.

Приём проектирования «поведение» состоит из двух частей:

1. Элементу ставится пользовательский атрибут, описывающий его поведение.
2. При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут, производит соответствующее действие.

### Зачем использовать:

- Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
- Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
- Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.

### Ограничения:

- Событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать event.stopPropagation().
- Делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.


## [Всплытие и погружение событий](https://learn.javascript.ru/bubbling-and-capturing)

### Всплытие

Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

`event.target` - элемент, на котором произошло событие

`this` (=`event.currentTarget`) - это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

#### Исключения
- submit, focus, blur, load, unload, change, reset, scroll
- focus не всплывает, но его можно перехватить

#### Прекращение всплытия

- `event.preventDefault()` prevents the default browser behavior for a given element
- `event.stopPropagation()` stops an event from bubbling or propagating up the DOM tree
- `return false` is a combination of both preventDefault() and stopPropagation()
- `event.stopImmediatePropagation()` - не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе
- `event.defaultPrevented` установлено в true, если действие по умолчанию было предотвращено, и false, если нет.
- Опция `passive: true` для `addEventListener` сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как touchstart и touchmove, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.

Вопросы:
1. Какие могут быть проблемы, если использовать прекращение всплытия?

### Погружение

Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент `addEventListener`:
- Если аргумент true, то событие будет перехвачено по дороге вниз.
- Если аргумент false, то событие будет поймано при всплытии.

Вопросы:
1. Использовал ли где-нибудь? Где еще может быть использована?

## Хойстинг или поднятие

```
console.log(hoist);
var hoist = 'The variable has been hoisted.';

// Вывод: undefined

'use strict';

console.log(hoist); // Вывод: ReferenceError: hoist is not defined
hoist = 'Hoisted';

console.log(hoist); // Вывод: ReferenceError: hoist is not defined ...
let hoist = 'The variable has been hoisted.';
```

Поднятие функций и функциональных выражений: функции поднимаются, а выражения нет

## Способы работы с асинхронным кодом:
- Callbacks
- Promises

Очередь событий - Асинхронные операции, такие как промисы, помещаются в очередь событий, которая запускается после завершения обработки основного потока, чтобы они не блокировали выполнение JavaScript-кода. Поставленные в очередь операции завершатся как можно скорее, а затем вернут свои результаты в среду JavaScript.

В чем преимущество Promises?

Proxy https://learn.javascript.ru/proxy

CSS
 Поток документа
 Вырвать элемент из потока  

React 
Классовые и функциональные компоненты
 Хуки и метода жизненного цикла 
useContext
 Batching
 
## Дополнительные вопросы:

1. Чем отличается `addEventListener` и `document.on<событие>`?
2. Куда еще собеседуешься?\
3. Как оптимизировать веб-приложение:
- какие запросы долго отрабатывают, какие отдают слишком много данных, нет ли дублей, точно ли все из них нужны
- настроено ли сжатие и кэширование
- можно ли заменить растровую графику на векторную, оптимизированы ли svg-файлы
- прописана ли мемоизация компонентов и их частей
- используется ли продакшн-сборка, включена ли минимизация исходников

Promises
обработка событий
Async await
Event Loop
Var Let Const
Микротаски/Таски
Замыкания

React
Synthetic events
Redux/MobX
Зачем нужен key

CSS
Поставить элемент по центру
Чем отличаются блочные от строчных
БЭМ-нотация классов стилей

Разное
Webpack
Yarn
PCSS
i18n
Docker